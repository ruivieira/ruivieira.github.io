<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Blog on Rui Vieira</title><link>https://ruivieira.dev/blog/</link><description>Recent content in Blog on Rui Vieira</description><generator>Hugo -- gohugo.io</generator><language>en-uk</language><atom:link href="https://ruivieira.dev/blog/index.xml" rel="self" type="application/rss+xml"/><item><title>KNative missing CRDs</title><link>https://ruivieira.dev/blog/2023-09-07.html</link><pubDate>Thu, 07 Sep 2023 00:00:00 +0000</pubDate><guid>https://ruivieira.dev/blog/2023-09-07.html</guid><description>If you&amp;rsquo;re using Minikube with Kubernetes 1.27.3 to install KServe 0.9 or 0.10, you might encounter this error:
resource mapping not found for name: &amp;#34;activator&amp;#34; namespace: &amp;#34;knative-serving&amp;#34; from &amp;#34;https://github.com/knative/serving/releases/download/knative-v1.7.0/serving-core.yaml&amp;#34;: no matches for kind &amp;#34;HorizontalPodAutoscaler&amp;#34; in version &amp;#34;autoscaling/v2beta2&amp;#34; ensure CRDs are installed first resource mapping not found for name: &amp;#34;webhook&amp;#34; namespace: &amp;#34;knative-serving&amp;#34; from &amp;#34;https://github.com/knative/serving/releases/download/knative-v1.7.0/serving-core.yaml&amp;#34;: no matches for kind &amp;#34;HorizontalPodAutoscaler&amp;#34; in version &amp;#34;autoscaling/v2beta2&amp;#34; Here&amp;rsquo;s the main issue:
Kubernetes 1.27.3 no longer supports the autoscaling/v2beta2 API version of HorizontalPodAutoscaler.</description></item><item><title>JUnit null and empty sources</title><link>https://ruivieira.dev/blog/2023-09-05.html</link><pubDate>Tue, 05 Sep 2023 00:00:00 +0000</pubDate><guid>https://ruivieira.dev/blog/2023-09-05.html</guid><description>Today I learned about JUnit&amp;rsquo;s ability to use null sources in conjunction with @ParamterizedTest. Example:
@ParameterizedTest @NullAndEmptySource @ValueSource(strings = {&amp;#34;test&amp;#34;, &amp;#34;JUnit&amp;#34;}) void nullAndEmptyTest(String text) { Assertions.assertTrue(text == null || text.trim().isEmpty() || &amp;#34;test&amp;#34;.equals(text) || &amp;#34;JUnit&amp;#34;.equals(text)); } There&amp;rsquo;s also @NullSource and @EmptySource.</description></item><item><title>LunarVim</title><link>https://ruivieira.dev/blog/2023-09-04.html</link><pubDate>Mon, 04 Sep 2023 00:00:00 +0000</pubDate><guid>https://ruivieira.dev/blog/2023-09-04.html</guid><description>Been trying out NeoVim in the format of LunarVim.
To use with a GUI on macOS, I use NeoVide, with the command
neovide --neovim-bin ~/.local/bin/lvim --multigrid --maximized --frame none If you are planning on using Neovim I recommend using a tree-sitter-aware theme. You can find a list here. My personal favourites are modus and gruvbox-material.</description></item><item><title>Hatch Poetry</title><link>https://ruivieira.dev/blog/2023-09-03.html</link><pubDate>Sun, 03 Sep 2023 00:00:00 +0000</pubDate><guid>https://ruivieira.dev/blog/2023-09-03.html</guid><description>I&amp;rsquo;ve been a long-time user of Poetry for my Python projects, and it&amp;rsquo;s been a welcome change. However, my recent exploration into Hatch has sparked my interest.
Poetry simplifies dependency management with its unified pyproject.toml, but Hatch excels in scenarios requiring complex workflows. A common personal use-case is Docker multi-stage builds. Hatch, with its conventional requirements.txt and setup.py, offers more granular control, making complex configurations easier.
Hatch also aligns closely with the existing Python ecosystem due to its use of traditional setup files, linking old with new workflows, ensuring a better integration.</description></item><item><title>Exception Bubbling in Python</title><link>https://ruivieira.dev/blog/2023-09-02.html</link><pubDate>Sat, 02 Sep 2023 00:00:00 +0000</pubDate><guid>https://ruivieira.dev/blog/2023-09-02.html</guid><description>Exception Bubbling in PythonOne aspect of Java that occasionally nudges at me is its explicit approach to exception handling. Java requires developers to either handle exceptions via try-catch blocks or declare them in method signatures. While it does enforce robustness, it sometimes feels a bit too constrained, especially when compared to the flexible nature of Python.
Recently, I crafted a solution in Python for k8sutils. Instead of the usual explicit exception handling or modifying method signatures, I created a Python decorator - akin to annotations in Java - that substitutes an exception for another without altering the underlying code.</description></item></channel></rss>