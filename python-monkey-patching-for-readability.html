<!DOCTYPE html>
<head>
    <link rel="icon" type="image/png" sizes="16x16" href="/favicons/favicon-16x16.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="48x48" href="/favicons/favicon.ico">

    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"
          integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">

    
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js"
            integrity="sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4"
            crossorigin="anonymous"></script>

    
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js"
            integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa" crossorigin="anonymous"
            onload="renderMathInElement(document.body);"></script>

    <link href="https://fonts.googleapis.com/css?family=Nunito:400,300i,800&display=swap" rel="stylesheet"/>
    <link href="/assets/style.css" rel="stylesheet"/>
    <title>ruivieira.dev - Python monkey patching (for readability)</title>
    <script type="application/javascript">
        var doNotTrack = false;
        if (!doNotTrack) {
            (function (i, s, o, g, r, a, m) {
                i['GoogleAnalyticsObject'] = r;
                i[r] = i[r] || function () {
                    (i[r].q = i[r].q || []).push(arguments)
                }, i[r].l = 1 * new Date();
                a = s.createElement(o),
                    m = s.getElementsByTagName(o)[0];
                a.async = 1;
                a.src = g;
                m.parentNode.insertBefore(a, m)
            })(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');
            ga('create', 'UA-10507665-2', 'auto');

            ga('send', 'pageview');
        }
    </script>
</head>
<body>

<div id="sidebar">
    
        <h2>Contents</h2>
        <ul>
            
                <li><a href="#bound-and-unbound-methods">Bound and unbound methods</a></li>
            
                <li><a href="#abstract-classes">Abstract classes</a></li>
            
                <li><a href="#private-methods">Private methods</a></li>
            
                <li><a href="#builtins">Builtins</a></li>
            
        </ul>
    
    
        <h2>Backlinks</h2>

        <ul>
            
                <li><a href="index.html">index</a><sup>&#5833</sup></li>
            
            <li><a href="/content.html">content</a><sup>&#5833</sup></li>

        </ul>
    
    <div class="footer">
        modified 1609451973
    </div>

</div>

<div id="content">
    <h1 id="python-monkey-patching-for-readability">Python monkey patching (for readability)</h1>
<p>When preparing a <a href="https://jupyter.org/">Jupyter</a> notebook for a workshop on recommendation engines which I've presented with a colleague, I was faced with the following problem:</p>
<blockquote>
<p>&quot;How to break a large class definition into several cells so it can be presented step-by-step.&quot;</p>
</blockquote>
<p>Having the ability to declare a rather complex (and large) <a href="python.html">Python</a> class in separate cells has several advantages, the obvious one being the ability to fully document each method's functionality with Markdown, rather than comments.<br />
Python does allow for functionality to be added to classes after their declaration via the assignment of methods through attributes. This is commonly known as &quot;monkey patching&quot; and hinges on the concepts of <em>bound</em> and <em>unbound</em> methods.</p>
<p>I will show a quick and general overview of the methods that Python puts at our disposal for dynamic runtime object manipulation, but for a more in-depth please consult the official <a href="https://docs.python.org/3/">Python documentation</a>.</p>
<h2 id="bound-and-unbound-methods">Bound and unbound methods</h2>
<p>Let's first look at bound methods. If we assume a class called <code>Class</code> and an instance <code>instance</code>, with an instance method <code>bound</code> and class method <code>unbound</code> such that</p>
<pre style="background-color:#fff"><span style="color:#000;font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Class</span>:
	<span style="color:#000;font-weight:bold">def</span> <span style="color:#900;font-weight:bold">bound</span>(<span style="color:#999">self</span>):
		<span style="color:#000;font-weight:bold">pass</span>
	<span style="color:#3c5d5d;font-weight:bold">@staticmethod</span>
	<span style="color:#000;font-weight:bold">def</span> <span style="color:#900;font-weight:bold">unbound</span>():
		<span style="color:#000;font-weight:bold">pass</span>

instance <span style="color:#000;font-weight:bold">=</span> Class()
</pre><p>Then <code>foo</code> is a bound method and <code>bar</code> is an unbound method.<br />
This definition, in practice, can be exemplified by the standard way of calling <code>.foo()</code>, which is</p>
<pre style="background-color:#fff">instance<span style="color:#000;font-weight:bold">.</span>bound()
</pre><p>which in turn is equivalent to</p>
<pre style="background-color:#fff">Class<span style="color:#000;font-weight:bold">.</span>bound(instance)
</pre><p>The standard way of calling <code>unbound</code> is , similarly</p>
<pre style="background-color:#fff">instance<span style="color:#000;font-weight:bold">.</span>unbound()
</pre><p>This, however, is equivalent to</p>
<pre style="background-color:#fff">Class<span style="color:#000;font-weight:bold">.</span>unbound()
</pre><p>In the unbound case, we can see there's no need to pass the class instance. <code>unbound</code> is <em>not bound</em> to the class instance.</p>
<p>As mentioned before, Python allow us to change the class attributes at runtime. If we consider a method such as</p>
<pre style="background-color:#fff"><span style="color:#000;font-weight:bold">def</span> <span style="color:#900;font-weight:bold">newBound</span>(<span style="color:#999">self</span>):
	<span style="color:#000;font-weight:bold">pass</span>
</pre><p>we can then add it to the class, even after declaring it. For instance:</p>
<pre style="background-color:#fff">Class<span style="color:#000;font-weight:bold">.</span>newBound <span style="color:#000;font-weight:bold">=</span> newBound
instance <span style="color:#000;font-weight:bold">=</span> Class()
instance<span style="color:#000;font-weight:bold">.</span>newBound() <span style="color:#998;font-style:italic"># Class.newBound(instance)</span>
</pre><p>It is interesting to note that any type of function definition will work, since functions are first class objects in Python. As such, if the method can be written as a single statement, a <code>lambda</code> could also be used, <em>i.e.</em></p>
<pre style="background-color:#fff">Class<span style="color:#000;font-weight:bold">.</span>newBound <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">lambda</span> <span style="color:#999">self</span>: <span style="color:#000;font-weight:bold">print</span>(<span style="color:#d14">&#34;I&#39;m a lambda&#34;</span>)
</pre><p>A limitation of the &quot;monkey patching&quot; method, is that attributes can only be changed at the class definition level.<br />
As an example, although possible, it is not trivial to add the <code>.newBound()</code> method to <code>instance</code>.</p>
<p>A solution is to either call the descriptor methods (which allow for instance attribute manipulation), or declare the instance attribute as a <code>MethodType</code>.</p>
<p>To illustrate this in our case:</p>
<pre style="background-color:#fff"><span style="color:#000;font-weight:bold">import</span> <span style="color:#555">types</span>
instance<span style="color:#000;font-weight:bold">.</span>newBound <span style="color:#000;font-weight:bold">=</span> types<span style="color:#000;font-weight:bold">.</span>MethodType(newBound, instance)
instance<span style="color:#000;font-weight:bold">.</span>newBound() <span style="color:#998;font-style:italic"># Prints &#34;I&#39;m a lambda&#34;</span>
</pre><p>This method is precisely, as mentioned, to change attributes for a specific instance, so in this case, if we try to access the bound method from another instance <code>anotherInstance</code>, it would fail</p>
<pre style="background-color:#fff">anotherInstance <span style="color:#000;font-weight:bold">=</span> Class()
anotherInstance<span style="color:#000;font-weight:bold">.</span>newBound() <span style="color:#998;font-style:italic"># fails with AttributeError</span>
</pre><h2 id="abstract-classes">Abstract classes</h2>
<p>Python supports abstract classes, <em>i.e.</em> the definition of &quot;blueprint&quot; classes for which we delegate the concrete implementation of abstract methods to subclasses. In Python 3.x this is done via the <code>@abstractmethod</code> annotation. If we declare a class such as</p>
<pre style="background-color:#fff"><span style="color:#000;font-weight:bold">from</span> <span style="color:#555">abc</span> <span style="color:#000;font-weight:bold">import</span> ABC, abstractmethod
<span style="color:#000;font-weight:bold">class</span> <span style="color:#458;font-weight:bold">AbstractClass</span>(ABC):
	<span style="color:#3c5d5d;font-weight:bold">@abstractmethod</span>
	<span style="color:#000;font-weight:bold">def</span> <span style="color:#900;font-weight:bold">abstractMethod</span>(<span style="color:#999">self</span>):
		<span style="color:#000;font-weight:bold">pass</span>
</pre><p>we can then implement <code>abstractMethod</code> in all of <code>AbstractClass</code>'s subclasses:</p>
<pre style="background-color:#fff"><span style="color:#000;font-weight:bold">class</span> <span style="color:#458;font-weight:bold">ConcreteClass</span>(AbstractClass):
	<span style="color:#000;font-weight:bold">def</span> <span style="color:#900;font-weight:bold">abstractMethod</span>(<span style="color:#999">self</span>):
		<span style="color:#000;font-weight:bold">print</span>(<span style="color:#d14">&#34;Concrete class abstract method&#34;</span>)
</pre><p>We could, obviously, do this in Python <em>without</em> abstract classes, but this mechanism allows for a greater safety, since implementation of abstract methods is mandatory in this case. With regular classes, not implementing <code>abstractMethod</code> would simply assume we were using the parent's definition.</p>
<p>Unfortunately, monkey patching of abstract methods is not supported in Python. We <em>could</em> monkey patch the concrete class:</p>
<pre style="background-color:#fff">ConcreteClass<span style="color:#000;font-weight:bold">.</span>newBound <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">lambda</span> <span style="color:#999">self</span>: <span style="color:#000;font-weight:bold">print</span>(<span style="color:#d14">&#34;New &#39;child&#39; bound&#34;</span>)
c <span style="color:#000;font-weight:bold">=</span> ConcreteClass()
c<span style="color:#000;font-weight:bold">.</span>newBound() <span style="color:#998;font-style:italic"># prints &#34;New &#39;child&#39; bound&#34;</span>
</pre><p>And we could even add a new bound method to the superclass, which will be available to all subclasses:</p>
<pre style="background-color:#fff">AbstractClass<span style="color:#000;font-weight:bold">.</span>newBound <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">lambda</span> <span style="color:#999">self</span>: <span style="color:#000;font-weight:bold">print</span>(<span style="color:#d14">&#34;New &#39;parent&#39; bound&#34;</span>)
c <span style="color:#000;font-weight:bold">=</span> ConcreteClass()
c<span style="color:#000;font-weight:bold">.</span>newBound() <span style="color:#998;font-style:italic"># prints &#34;New &#39;parent&#39; bound&#34;</span>
</pre><p>However, we can't add abstract methods with monkey patching. This is <a href="https://docs.python.org/3/library/abc.html#abc.abstractmethod">a documented exception</a> of this functionality with the specific warning that</p>
<blockquote>
<p>Dynamically adding abstract methods to a class, or attempting to modify the abstraction status of a method or class once it is created, are not supported. The abstractmethod() only affects subclasses derived using regular inheritance; &quot;virtual subclasses&quot; registered with the ABC's register() method are not affected.</p></p>
</blockquote>
<h2 id="private-methods">Private methods</h2>
<p>We can dynamically add and replace inner methods, such as:</p>
<pre style="background-color:#fff"><span style="color:#000;font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Class</span>:
	<span style="color:#000;font-weight:bold">def</span> <span style="color:#900;font-weight:bold">_inner</span>(<span style="color:#999">self</span>):
		<span style="color:#000;font-weight:bold">print</span>(<span style="color:#d14">&#34;Inner bound&#34;</span>)
	<span style="color:#000;font-weight:bold">def</span> <span style="color:#900;font-weight:bold">__private</span>(<span style="color:#999">self</span>):
		<span style="color:#000;font-weight:bold">print</span>(<span style="color:#d14">&#34;Private bound&#34;</span>)
	<span style="color:#000;font-weight:bold">def</span> <span style="color:#900;font-weight:bold">callNewPrivate</span>(<span style="color:#999">self</span>):
		<span style="color:#999">self</span><span style="color:#000;font-weight:bold">.</span>__newPrivate()

Class<span style="color:#000;font-weight:bold">.</span>_newInner <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">lambda</span> <span style="color:#999">self</span>: <span style="color:#000;font-weight:bold">print</span>(<span style="color:#d14">&#34;New inner bound&#34;</span>)
c <span style="color:#000;font-weight:bold">=</span> Class()
c<span style="color:#000;font-weight:bold">.</span>_inner() <span style="color:#998;font-style:italic"># prints &#34;Inner bound&#34;</span>
c<span style="color:#000;font-weight:bold">.</span>_newInner() <span style="color:#998;font-style:italic"># prints &#34;New inner bound&#34;</span>
</pre><p>However, private methods behave differently. Python enforces name mangling for private methods. As specified in the documentation:</p>
<blockquote>
<p>Since there is a valid use-case for class-private members (namely to avoid name clashes of names with names defined by subclasses), there is limited support for such a mechanism, called name mangling. Any identifier of the form <code>__spam</code> (at least two leading underscores, at most one trailing underscore) is textually replaced with <code>_classname__spam</code>, where classname is the current class name with leading underscore(s) stripped. This mangling is done without regard to the syntactic position of the identifier, as long as it occurs within the definition of a class.</p>
</blockquote>
<p>We can then still access the private methods (although we probably shouldn't), but monkey patching won't work as before due to the above.</p>
<pre style="background-color:#fff">c<span style="color:#000;font-weight:bold">.</span>_Class__private() <span style="color:#998;font-style:italic"># Private bound</span>
Class<span style="color:#000;font-weight:bold">.</span>__newPrivate <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">lambda</span> <span style="color:#999">self</span>: <span style="color:#000;font-weight:bold">print</span>(<span style="color:#d14">&#34;New private bound&#34;</span>)
c <span style="color:#000;font-weight:bold">=</span> Class()
c<span style="color:#000;font-weight:bold">.</span>_Class__newPrivate() <span style="color:#998;font-style:italic"># fails with AttributeError</span>
</pre><p>We have defined a new method called <code>__newPrivate()</code> but interestingly, this method is <em>not</em> private. We can see this by calling it directly (which is allowed) and by calling the new &quot;private&quot; method from inside the class as <code>self.__newPrivate()</code>:</p>
<pre style="background-color:#fff">c<span style="color:#000;font-weight:bold">.</span>__newPrivate() <span style="color:#998;font-style:italic"># prints &#34;New private bound&#34;</span>
c<span style="color:#000;font-weight:bold">.</span>callNewPrivate() 
<span style="color:#998;font-style:italic"># fails with AttributeError (can&#39;t find _Class_NewPrivate)</span>
</pre><p>It is possible to perform some OOP abuse and declare the private method by mangling the name ourselves. In this case we could then do:</p>
<pre style="background-color:#fff">Class<span style="color:#000;font-weight:bold">.</span>_Class__newPrivate <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">lambda</span> <span style="color:#999">self</span>: <span style="color:#000;font-weight:bold">print</span>(<span style="color:#d14">&#34;New private bound&#34;</span>)
c <span style="color:#000;font-weight:bold">=</span> Class()
c<span style="color:#000;font-weight:bold">.</span>_Class__newPrivate() <span style="color:#998;font-style:italic"># prints &#34;New private bound&#34;</span>
c<span style="color:#000;font-weight:bold">.</span>callNewPrivate() <span style="color:#998;font-style:italic"># prints &#34;New private bound&#34;</span>
</pre><h2 id="builtins">Builtins</h2>
<p>Is it possible to monkey patch builtin classes in Python, <em>e.g.</em> <code>int</code> or <code>float</code>?<br />
In short, yes, it is.</p>
<p>Although the usefulness is arguable and I <em>strongly</em> urge not to do this in any production scenario, we'll look at how to achieve this, for the sake of completeness. A very interesting and educational read is available from the <a href="https://github.com/clarete/forbiddenfruit">Forbidden Fruit</a> Python module.</p>
<p>Primitive (or <em>builtin</em>) classes in Python are typically written in C and as such some of these meta-programming facilities require jumping through extra hoops (as well as being a Very Bad Ideaâ„¢).<br />
Let's first look at the integer class representation, <code>int</code>.</p>
<p>A <code>int</code> doesn't allow bound methods to be added dynamically as previously. For instance:</p>
<pre style="background-color:#fff">p <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">5</span>
<span style="color:#0086b3">type</span>(p) <span style="color:#998;font-style:italic"># int</span>
</pre><p>We can try to add a method to <code>int</code> to square the value of the instance:</p>
<pre style="background-color:#fff"><span style="color:#0086b3">int</span><span style="color:#000;font-weight:bold">.</span>square <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">lambda</span> <span style="color:#999">self</span>: <span style="color:#999">self</span> <span style="color:#000;font-weight:bold">**</span> <span style="color:#099">2</span>
</pre><p>This fails with the error <code>TypeError: can't set attributes of built-in/extension type 'int'</code>.<br />
The solution (as presented in Forbidden Fruit) is to first create classes to hold the <code>ctype</code> information of a builtin (C) class. We subclass <code>ctypes</code> Python representation of a C <code>struct</code> in native byte order and hold the <code>signed int</code> size and pointer to <code>PyObject</code>.</p>
<pre style="background-color:#fff"><span style="color:#000;font-weight:bold">import</span> <span style="color:#555">ctypes</span>
<span style="color:#000;font-weight:bold">class</span> <span style="color:#458;font-weight:bold">PyObject</span>(ctypes<span style="color:#000;font-weight:bold">.</span>Structure):
	<span style="color:#000;font-weight:bold">pass</span>

PyObject<span style="color:#000;font-weight:bold">.</span>fields <span style="color:#000;font-weight:bold">=</span> [
	(<span style="color:#d14">&#39;ob_refcnt&#39;</span>, ctypes<span style="color:#000;font-weight:bold">.</span>c_int),
	(<span style="color:#d14">&#39;ob_type&#39;</span>, ctypes<span style="color:#000;font-weight:bold">.</span>POINTER(PyObject)),
]
</pre><p>Next we create a holder for Python objects slots, containing a reference to the <code>ctype</code> structure:</p>
<pre style="background-color:#fff"><span style="color:#000;font-weight:bold">class</span> <span style="color:#458;font-weight:bold">SlotsProxy</span>(PyObject):
	_fields_ <span style="color:#000;font-weight:bold">=</span> [(<span style="color:#d14">&#39;dict&#39;</span>, ctypes<span style="color:#000;font-weight:bold">.</span>POINTER(PyObject))]
</pre><p>The final step is extract the <code>PyProxyDict</code> from the object referenced by the pointer.<br />
Ideally, we should get the builtin's namespace so we can freely set attributes as we did previously. A helper function to retrieve the builtins (mutable) namespace can then be:</p>
<pre style="background-color:#fff"><span style="color:#000;font-weight:bold">def</span> <span style="color:#900;font-weight:bold">patch</span>(klass):
	name <span style="color:#000;font-weight:bold">=</span> klass<span style="color:#000;font-weight:bold">.</span>__name__
	target <span style="color:#000;font-weight:bold">=</span> klass<span style="color:#000;font-weight:bold">.</span>__dict__
	proxy_dict <span style="color:#000;font-weight:bold">=</span> SlotsProxy<span style="color:#000;font-weight:bold">.</span>from_address(<span style="color:#0086b3">id</span>(target))
	namespace <span style="color:#000;font-weight:bold">=</span> {}

	ctypes<span style="color:#000;font-weight:bold">.</span>pythonapi<span style="color:#000;font-weight:bold">.</span>PyDict_SetItem(
		ctypes<span style="color:#000;font-weight:bold">.</span>py_object(namespace),
		ctypes<span style="color:#000;font-weight:bold">.</span>py_object(name),
		proxy_dict<span style="color:#000;font-weight:bold">.</span>dict,
	)
	<span style="color:#000;font-weight:bold">return</span> namespace[name]
</pre><p>We can now easily patch builtin classes. Let's try to add the square method again by first retrieving the namespace (stored below in <code>d</code>) and setting it directly</p>
<pre style="background-color:#fff">d <span style="color:#000;font-weight:bold">=</span> patch(<span style="color:#0086b3">int</span>)
d[<span style="color:#d14">&#34;square&#34;</span>] <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">lambda</span> <span style="color:#999">self</span>: <span style="color:#999">self</span> <span style="color:#000;font-weight:bold">**</span> <span style="color:#099">2</span>

p<span style="color:#000;font-weight:bold">.</span>square() <span style="color:#998;font-style:italic"># 25</span>
</pre><p>All future instance of <code>int</code> will also contain the square method now:</p>
<pre style="background-color:#fff">(<span style="color:#099">2</span> <span style="color:#000;font-weight:bold">+</span> p)<span style="color:#000;font-weight:bold">.</span>square() <span style="color:#998;font-style:italic"># 49</span>
</pre><h1 id="conclusion">Conclusion</h1>
<p>&quot;Monkey patching&quot; is usually, and rightly so, considered a code smell, due to the increased indirection and potential source of unwanted surprises.<br />
However, having the ability to &quot;monkey patch&quot; classes in Python allows us to write Jupyter notebooks in a more literate, fluid way rather than presenting the user with a &quot;wall of code&quot;.<br />
Thank you for reading. If you have any comments or suggestions please drop me a message on <a href="https://mastodon.technology/@ruivieira">Mastodon</a>.</p>

    <div class="footer">
        <span class="cc-symbol">&#127341;</span> 2020 CC BY Rui Vieira
    </div>
</div>

</body>
</html>